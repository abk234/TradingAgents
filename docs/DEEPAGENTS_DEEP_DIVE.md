# DeepAgents Deep Dive: Technical Analysis & Integration Strategies

**Date:** November 17, 2025  
**Purpose:** Deep technical analysis of deepagents patterns and detailed integration strategies for TradingAgents  
**Status:** ðŸ”¬ TECHNICAL DEEP DIVE

---

## Table of Contents

1. [Middleware Architecture Deep Dive](#1-middleware-architecture-deep-dive)
2. [Summarization Strategy](#2-summarization-strategy)
3. [TodoList Pattern Implementation](#3-todolist-pattern-implementation)
4. [Sub-Agent Delegation Pattern](#4-sub-agent-delegation-pattern)
5. [Filesystem Tools Standardization](#5-filesystem-tools-standardization)
6. [Human-in-the-Loop Integration](#6-human-in-the-loop-integration)
7. [Context Management & Token Optimization](#7-context-management--token-optimization)
8. [Implementation Roadmap](#8-implementation-roadmap)

---

## 1. Middleware Architecture Deep Dive

### 1.1 How DeepAgents Middleware Works

**Core Concept:**
```python
# DeepAgents middleware pattern
class AgentMiddleware:
    tools: List[Tool] = []
    
    def modify_prompt(self, prompt: str) -> str:
        """Add instructions to system prompt"""
        return prompt
    
    def modify_state(self, state: Dict) -> Dict:
        """Modify state before agent execution"""
        return state
```

**Key Insight:** Middleware wraps agents and injects capabilities without modifying agent code.

### 1.2 TradingAgents Current Architecture

**Current State Management:**
```python
# tradingagents/agents/utils/agent_states.py
class AgentState(MessagesState):
    market_report: Annotated[str, "Report from Market Analyst"]
    sentiment_report: Annotated[str, "Report from Social Media Analyst"]
    news_report: Annotated[str, "Report from News Researcher"]
    fundamentals_report: Annotated[str, "Report from Fundamentals Researcher"]
    investment_plan: Annotated[str, "Plan generated by Analyst"]
    trader_investment_plan: Annotated[str, "Plan generated by Trader"]
    final_trade_decision: Annotated[str, "Final decision"]
    # ... more fields
```

**Problem:** No middleware layer - tools and logic are embedded in agents.

### 1.3 Proposed Middleware Architecture

**Design Pattern:**
```python
# tradingagents/middleware/base.py
from abc import ABC, abstractmethod
from typing import List, Dict, Any
from langchain_core.tools import BaseTool

class TradingMiddleware(ABC):
    """Base middleware for TradingAgents"""
    
    @property
    @abstractmethod
    def tools(self) -> List[BaseTool]:
        """Tools this middleware provides"""
        pass
    
    @abstractmethod
    def modify_prompt(self, prompt: str, agent_type: str) -> str:
        """Modify system prompt for specific agent"""
        pass
    
    def modify_state(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Modify state before agent execution (optional)"""
        return state
    
    def post_process(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Process state after agent execution (optional)"""
        return state
```

**Concrete Implementations:**

#### 1.3.1 TodoListMiddleware

```python
# tradingagents/middleware/todolist.py
from langchain_core.tools import tool
from typing import List, Dict, Any
from .base import TradingMiddleware

@tool
def write_todos(tasks: List[str], analysis_id: str = None) -> str:
    """Create a structured todo list for tracking analysis progress.
    
    Args:
        tasks: List of task descriptions
        analysis_id: Optional ID for this analysis (for persistence)
    
    Returns:
        Confirmation message with todo list ID
    """
    # Store todos in state or database
    todo_id = f"todo_{analysis_id or uuid.uuid4()}"
    # Implementation...
    return f"Created todo list {todo_id} with {len(tasks)} tasks"

@tool
def read_todos(todo_id: str = None) -> str:
    """Read current todo list state.
    
    Args:
        todo_id: Optional specific todo list ID, otherwise returns current
    
    Returns:
        Formatted todo list with status
    """
    # Retrieve from state or database
    # Implementation...
    return formatted_todos

class TodoListMiddleware(TradingMiddleware):
    """Middleware for task planning and progress tracking"""
    
    @property
    def tools(self) -> List[BaseTool]:
        return [write_todos, read_todos]
    
    def modify_prompt(self, prompt: str, agent_type: str) -> str:
        todo_instructions = """
        
## Task Planning Tools

You have access to task planning tools:
- `write_todos`: Create a structured task list before starting complex work
- `read_todos`: Check current progress on tasks

**When to use todos:**
- Complex multi-step analyses (e.g., analyzing multiple stocks)
- Long-running workflows (e.g., daily screener)
- Tasks requiring coordination between agents

**When NOT to use todos:**
- Simple single-step queries
- Quick lookups
- Tasks that complete in < 10 seconds

**Example workflow:**
1. User asks: "Analyze NVDA, AAPL, and MSFT"
2. Create todos: ["Analyze NVDA", "Analyze AAPL", "Analyze MSFT"]
3. Execute each task
4. Mark todos as complete as you progress
"""
        return prompt + todo_instructions
```

**Integration Point:**
```python
# tradingagents/graph/trading_graph.py (modified)
class TradingAgentsGraph:
    def __init__(self, ..., middleware: List[TradingMiddleware] = None):
        self.middleware = middleware or []
        
        # Collect all tools from middleware
        self.middleware_tools = []
        for mw in self.middleware:
            self.middleware_tools.extend(mw.tools)
        
        # Modify prompts for each agent
        self._apply_middleware_prompts()
    
    def _apply_middleware_prompts(self):
        """Apply middleware prompt modifications"""
        for agent_name, agent_func in self.agent_factories.items():
            original_prompt = get_agent_prompt(agent_name)
            modified_prompt = original_prompt
            
            for mw in self.middleware:
                modified_prompt = mw.modify_prompt(modified_prompt, agent_name)
            
            set_agent_prompt(agent_name, modified_prompt)
```

**Usage Example:**
```python
# Create graph with todo middleware
from tradingagents.middleware.todolist import TodoListMiddleware

graph = TradingAgentsGraph(
    selected_analysts=["market", "social", "news", "fundamentals"],
    middleware=[TodoListMiddleware()],
    config=config
)

# Agents can now use write_todos and read_todos tools
```

---

## 2. Summarization Strategy

### 2.1 Current Token Accumulation Problem

**Analysis Flow:**
```
1. Analyst Team (4 agents) â†’ ~15,000 tokens
2. Research Team Debate (3 agents, 2 rounds) â†’ ~25,000 tokens
3. Trader Agent â†’ ~10,000 tokens
4. Risk Team Debate (4 agents, 2 rounds) â†’ ~30,000 tokens
5. Portfolio Manager â†’ ~5,000 tokens

Total: ~85,000 tokens per analysis
```

**Problem:** All context passed forward, accumulating tokens.

### 2.2 DeepAgents Summarization Pattern

**Key Insight:** Summarize at boundaries between agent teams.

**Implementation:**
```python
# tradingagents/middleware/summarization.py
from typing import Dict, Any, List
from langchain_core.messages import AIMessage, HumanMessage, SystemMessage
from langchain_openai import ChatOpenAI
from .base import TradingMiddleware

class SummarizationMiddleware(TradingMiddleware):
    """Auto-summarize context when it exceeds token limits"""
    
    def __init__(
        self,
        token_threshold: int = 50000,  # Summarize if > 50k tokens
        summarization_model: str = "gpt-4o-mini",  # Fast, cheap model
        preserve_key_info: bool = True
    ):
        self.token_threshold = token_threshold
        self.summarization_model = summarization_model
        self.preserve_key_info = preserve_key_info
        self.llm = ChatOpenAI(model=summarization_model, temperature=0)
    
    @property
    def tools(self) -> List[BaseTool]:
        return []  # No tools, just state processing
    
    def modify_prompt(self, prompt: str, agent_type: str) -> str:
        return prompt  # No prompt modification
    
    def estimate_tokens(self, text: str) -> int:
        """Rough token estimation (4 chars = 1 token)"""
        return len(text) // 4
    
    def summarize_analyst_reports(self, state: Dict[str, Any]) -> str:
        """Summarize all analyst reports into concise format"""
        reports = []
        if state.get("market_report"):
            reports.append(f"Market: {state['market_report'][:500]}...")
        if state.get("sentiment_report"):
            reports.append(f"Sentiment: {state['sentiment_report'][:500]}...")
        if state.get("news_report"):
            reports.append(f"News: {state['news_report'][:500]}...")
        if state.get("fundamentals_report"):
            reports.append(f"Fundamentals: {state['fundamentals_report'][:500]}...")
        
        if not reports:
            return ""
        
        summary_prompt = f"""Summarize the following analyst reports into a concise format, preserving:
1. Key findings and signals
2. Critical data points (numbers, percentages)
3. Risk factors
4. Recommendations

Reports:
{chr(10).join(reports)}

Provide a structured summary (max 1000 tokens)."""
        
        messages = [
            SystemMessage(content="You are a financial analysis summarizer."),
            HumanMessage(content=summary_prompt)
        ]
        
        response = self.llm.invoke(messages)
        return response.content
    
    def summarize_debate(self, debate_state: Dict[str, Any]) -> str:
        """Summarize debate history"""
        history = debate_state.get("history", "")
        if not history or len(history) < 1000:
            return history
        
        summary_prompt = f"""Summarize this investment debate, preserving:
1. Key arguments from both sides
2. Critical concerns raised
3. Consensus points
4. Final recommendation

Debate History:
{history[:5000]}  # Limit input

Provide concise summary (max 800 tokens)."""
        
        messages = [
            SystemMessage(content="You are a debate summarizer."),
            HumanMessage(content=summary_prompt)
        ]
        
        response = self.llm.invoke(messages)
        return response.content
    
    def post_process(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Summarize state after agent team completes"""
        # Check if we need summarization
        total_tokens = sum(
            self.estimate_tokens(str(v)) 
            for v in state.values() 
            if isinstance(v, str)
        )
        
        if total_tokens < self.token_threshold:
            return state  # No summarization needed
        
        # Summarize at team boundaries
        modified_state = state.copy()
        
        # After Analyst Team completes
        if all([
            state.get("market_report"),
            state.get("sentiment_report"),
            state.get("news_report"),
            state.get("fundamentals_report")
        ]) and not state.get("_analyst_summarized"):
            analyst_summary = self.summarize_analyst_reports(state)
            modified_state["analyst_summary"] = analyst_summary
            modified_state["_analyst_summarized"] = True
            # Optionally clear full reports (or keep for reference)
            # modified_state["market_report"] = "[Summarized]"
        
        # After Research Team completes
        if state.get("investment_plan") and not state.get("_research_summarized"):
            debate_state = state.get("investment_debate_state", {})
            if isinstance(debate_state, dict) and debate_state.get("history"):
                debate_summary = self.summarize_debate(debate_state)
                modified_state["debate_summary"] = debate_summary
                modified_state["_research_summarized"] = True
        
        return modified_state
```

**Integration into Graph:**
```python
# tradingagents/graph/setup.py (modified)
class GraphSetup:
    def __init__(self, ..., summarization_middleware=None):
        self.summarization_middleware = summarization_middleware
    
    def setup_graph(self, selected_analysts):
        workflow = StateGraph(AgentState)
        
        # Add nodes...
        
        # Add summarization checkpoints
        if self.summarization_middleware:
            # After analyst team
            workflow.add_node(
                "Summarize Analysts",
                lambda state: self.summarization_middleware.post_process(state)
            )
            workflow.add_edge("Msg Clear Fundamentals", "Summarize Analysts")
            workflow.add_edge("Summarize Analysts", "Bull Researcher")
            
            # After research team
            workflow.add_node(
                "Summarize Research",
                lambda state: self.summarization_middleware.post_process(state)
            )
            workflow.add_edge("Research Manager", "Summarize Research")
            workflow.add_edge("Summarize Research", "Trader")
```

**Cost Savings Calculation:**
```python
# Before summarization:
# Analyst reports: 15,000 tokens
# Passed to Research: 15,000 tokens
# Research debate: 25,000 tokens (uses full 15k)
# Total: 40,000 tokens for research phase

# After summarization:
# Analyst reports: 15,000 tokens
# Summarized: 2,000 tokens (87% reduction)
# Passed to Research: 2,000 tokens
# Research debate: 8,000 tokens (uses summarized 2k)
# Total: 10,000 tokens for research phase

# Savings: 30,000 tokens (75% reduction) per analysis
# At $0.01 per 1k tokens: $0.30 saved per analysis
# For 100 analyses/day: $30/day = $900/month
```

---

## 3. TodoList Pattern Implementation

### 3.1 Detailed Design

**Todo Storage:**
```python
# tradingagents/middleware/todolist_storage.py
from typing import List, Dict, Optional
from datetime import datetime
from dataclasses import dataclass, field
from enum import Enum

class TodoStatus(Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

@dataclass
class TodoItem:
    id: str
    description: str
    status: TodoStatus = TodoStatus.PENDING
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    metadata: Dict = field(default_factory=dict)

@dataclass
class TodoList:
    id: str
    title: str
    items: List[TodoItem] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    context: Dict = field(default_factory=dict)  # Analysis ID, ticker, etc.
```

**Todo Management:**
```python
# tradingagents/middleware/todolist.py (expanded)
from .todolist_storage import TodoList, TodoItem, TodoStatus
import uuid
import json

class TodoListManager:
    """Manages todo lists in agent state"""
    
    def __init__(self):
        self.active_todos: Dict[str, TodoList] = {}
    
    def create_todo_list(
        self, 
        tasks: List[str], 
        title: str = "Analysis Tasks",
        context: Dict = None
    ) -> str:
        """Create a new todo list"""
        todo_id = str(uuid.uuid4())
        items = [
            TodoItem(id=str(uuid.uuid4()), description=task)
            for task in tasks
        ]
        
        todo_list = TodoList(
            id=todo_id,
            title=title,
            items=items,
            context=context or {}
        )
        
        self.active_todos[todo_id] = todo_list
        return todo_id
    
    def get_todo_list(self, todo_id: str = None) -> Optional[TodoList]:
        """Get todo list (most recent if ID not provided)"""
        if todo_id:
            return self.active_todos.get(todo_id)
        # Return most recent
        if self.active_todos:
            return max(self.active_todos.values(), key=lambda t: t.created_at)
        return None
    
    def mark_complete(self, todo_id: str, item_id: str):
        """Mark a todo item as complete"""
        todo_list = self.active_todos.get(todo_id)
        if not todo_list:
            return
        
        for item in todo_list.items:
            if item.id == item_id:
                item.status = TodoStatus.COMPLETED
                item.completed_at = datetime.now()
                break
    
    def format_todos(self, todo_list: TodoList) -> str:
        """Format todos for display"""
        lines = [f"ðŸ“‹ {todo_list.title}"]
        lines.append("=" * 50)
        
        for i, item in enumerate(todo_list.items, 1):
            status_icon = {
                TodoStatus.PENDING: "â³",
                TodoStatus.IN_PROGRESS: "ðŸ”„",
                TodoStatus.COMPLETED: "âœ…",
                TodoStatus.CANCELLED: "âŒ"
            }.get(item.status, "â“")
            
            lines.append(f"{i}. {status_icon} {item.description}")
            if item.status == TodoStatus.COMPLETED and item.completed_at:
                lines.append(f"   Completed: {item.completed_at.strftime('%H:%M:%S')}")
        
        completed = sum(1 for item in todo_list.items if item.status == TodoStatus.COMPLETED)
        total = len(todo_list.items)
        lines.append(f"\nProgress: {completed}/{total} tasks completed")
        
        return "\n".join(lines)

# Tool implementations
@tool
def write_todos(tasks: List[str], title: str = "Analysis Tasks") -> str:
    """Create a structured todo list for tracking progress.
    
    Use this when:
    - Starting a complex multi-step analysis
    - Need to track progress through a workflow
    - Coordinating multiple analysis steps
    
    Args:
        tasks: List of task descriptions (e.g., ["Analyze NVDA", "Check fundamentals"])
        title: Optional title for the todo list
    
    Returns:
        Confirmation with todo list ID
    """
    manager = get_todo_manager()  # Get from context/state
    todo_id = manager.create_todo_list(tasks, title)
    return f"âœ… Created todo list '{title}' with {len(tasks)} tasks. ID: {todo_id}"

@tool
def read_todos(todo_id: str = None) -> str:
    """Read current todo list and progress.
    
    Args:
        todo_id: Optional specific todo list ID
    
    Returns:
        Formatted todo list with status
    """
    manager = get_todo_manager()
    todo_list = manager.get_todo_list(todo_id)
    
    if not todo_list:
        return "No active todo list found."
    
    return manager.format_todos(todo_list)
```

**Usage in Agent Workflow:**
```python
# Example: Screener workflow with todos
def run_screener_with_todos():
    # Agent creates plan
    todos = write_todos([
        "Scan all tickers for technical indicators",
        "Calculate priority scores",
        "Identify top 5 opportunities",
        "Run deep analysis on top picks",
        "Generate summary report"
    ], title="Daily Screener Workflow")
    
    # Execute with progress tracking
    # Step 1: Scan
    scan_results = run_screener_scan()
    mark_todo_complete(todos, item_id="scan_tickers")
    
    # Step 2: Calculate scores
    scores = calculate_scores(scan_results)
    mark_todo_complete(todos, item_id="calculate_scores")
    
    # ... continue
```

---

## 4. Sub-Agent Delegation Pattern

### 4.1 Current vs. Proposed Architecture

**Current (Fixed Graph):**
```python
# tradingagents/graph/setup.py
workflow.add_node("Market Analyst", market_analyst_node)
workflow.add_node("Social Analyst", social_analyst_node)
# ... fixed structure
```

**Proposed (Dynamic Delegation):**
```python
# tradingagents/middleware/subagent.py
from langgraph.graph import CompiledGraph
from typing import Dict, Any, Optional

@tool
def delegate_to_subagent(
    task: str,
    subagent_type: str,
    context: Dict[str, Any] = None
) -> str:
    """Delegate a task to a specialized sub-agent.
    
    Args:
        task: Description of the task to delegate
        subagent_type: Type of sub-agent ("market", "fundamentals", "news", etc.)
        context: Optional context to pass to sub-agent
    
    Returns:
        Result from sub-agent
    """
    # Create isolated sub-agent
    subagent = create_subagent(subagent_type, context)
    
    # Run with isolated context
    result = subagent.invoke({
        "messages": [("human", task)],
        **context or {}
    })
    
    return result["messages"][-1].content

class SubAgentMiddleware(TradingMiddleware):
    """Middleware for dynamic sub-agent delegation"""
    
    def __init__(self, subagent_factories: Dict[str, callable]):
        self.subagent_factories = subagent_factories
    
    @property
    def tools(self) -> List[BaseTool]:
        return [delegate_to_subagent]
    
    def create_subagent(self, agent_type: str, context: Dict = None):
        """Create isolated sub-agent"""
        factory = self.subagent_factories.get(agent_type)
        if not factory:
            raise ValueError(f"Unknown sub-agent type: {agent_type}")
        
        # Create with isolated context
        return factory(context=context)
```

**Use Case: Conditional Analysis**
```python
# Instead of always running all 4 analysts:
# Current: Always runs market, social, news, fundamentals

# Proposed: Trader agent decides which analysts needed
def trader_agent(state):
    # Check if we need deep technical analysis
    if needs_technical_analysis(state):
        result = delegate_to_subagent(
            task="Perform detailed technical analysis",
            subagent_type="market",
            context={"ticker": state["company_of_interest"]}
        )
        state["market_report"] = result
    
    # Only run fundamentals if needed
    if needs_fundamentals(state):
        result = delegate_to_subagent(
            task="Analyze company fundamentals",
            subagent_type="fundamentals",
            context={"ticker": state["company_of_interest"]}
        )
        state["fundamentals_report"] = result
```

**Benefits:**
- **Cost Reduction**: Only run needed agents
- **Flexibility**: Dynamic agent selection
- **Isolation**: Sub-agents get fresh context
- **Parallelization**: Can spawn multiple sub-agents in parallel

---

## 5. Filesystem Tools Standardization

### 5.1 Standard Tool Set

```python
# tradingagents/middleware/filesystem.py
from langchain_core.tools import tool
from pathlib import Path
from typing import Optional, List
import json

@tool
def ls(directory: str) -> str:
    """List files in a directory (requires absolute path).
    
    Args:
        directory: Absolute path to directory
    
    Returns:
        Formatted list of files and directories
    """
    path = Path(directory)
    if not path.is_absolute():
        return f"Error: Path must be absolute. Got: {directory}"
    
    if not path.exists():
        return f"Error: Directory does not exist: {directory}"
    
    items = []
    for item in sorted(path.iterdir()):
        item_type = "ðŸ“" if item.is_dir() else "ðŸ“„"
        size = item.stat().st_size if item.is_file() else 0
        items.append(f"{item_type} {item.name} ({size:,} bytes)")
    
    return "\n".join(items) if items else "Directory is empty"

@tool
def read_file(file_path: str, offset: int = 0, limit: int = None) -> str:
    """Read content from a file with optional pagination.
    
    Args:
        file_path: Absolute path to file
        offset: Line number to start reading from (0-indexed)
        limit: Maximum number of lines to read
    
    Returns:
        File content (or portion if paginated)
    """
    path = Path(file_path)
    if not path.is_absolute():
        return f"Error: Path must be absolute. Got: {file_path}"
    
    if not path.exists():
        return f"Error: File does not exist: {file_path}"
    
    with open(path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    start = max(0, offset)
    end = start + limit if limit else len(lines)
    selected_lines = lines[start:end]
    
    content = "".join(selected_lines)
    if len(lines) > end:
        content += f"\n... ({len(lines) - end} more lines)"
    
    return content

@tool
def write_file(file_path: str, content: str, overwrite: bool = True) -> str:
    """Create or overwrite a file.
    
    Args:
        file_path: Absolute path to file
        content: Content to write
        overwrite: Whether to overwrite existing file
    
    Returns:
        Confirmation message
    """
    path = Path(file_path)
    if not path.is_absolute():
        return f"Error: Path must be absolute. Got: {file_path}"
    
    if path.exists() and not overwrite:
        return f"Error: File exists and overwrite=False: {file_path}"
    
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    return f"âœ… Written {len(content)} characters to {file_path}"

@tool
def edit_file(file_path: str, old_string: str, new_string: str) -> str:
    """Perform exact string replacement in a file.
    
    Args:
        file_path: Absolute path to file
        old_string: Exact text to replace
        new_string: Replacement text
    
    Returns:
        Confirmation message
    """
    path = Path(file_path)
    if not path.is_absolute():
        return f"Error: Path must be absolute. Got: {file_path}"
    
    if not path.exists():
        return f"Error: File does not exist: {file_path}"
    
    with open(path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    if old_string not in content:
        return f"Error: '{old_string}' not found in file"
    
    new_content = content.replace(old_string, new_string)
    
    with open(path, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    return f"âœ… Replaced text in {file_path}"

@tool
def glob(pattern: str, root_dir: str = "/") -> str:
    """Find files matching a pattern.
    
    Args:
        pattern: Glob pattern (e.g., "**/*.py", "results/*.json")
        root_dir: Root directory to search from (default: /)
    
    Returns:
        List of matching file paths
    """
    root = Path(root_dir)
    matches = list(root.glob(pattern))
    
    if not matches:
        return f"No files found matching pattern: {pattern}"
    
    return "\n".join(str(m) for m in sorted(matches))

@tool
def grep(pattern: str, file_path: str, context_lines: int = 0) -> str:
    """Search for text pattern in a file.
    
    Args:
        pattern: Text pattern to search for
        file_path: Absolute path to file
        context_lines: Number of context lines to include
    
    Returns:
        Matching lines with context
    """
    import re
    
    path = Path(file_path)
    if not path.exists():
        return f"Error: File does not exist: {file_path}"
    
    with open(path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    matches = []
    for i, line in enumerate(lines):
        if pattern.lower() in line.lower():
            start = max(0, i - context_lines)
            end = min(len(lines), i + context_lines + 1)
            context = "".join(lines[start:end])
            matches.append(f"Line {i+1}:\n{context}")
    
    if not matches:
        return f"No matches found for '{pattern}' in {file_path}"
    
    return "\n\n".join(matches)

class FilesystemMiddleware(TradingMiddleware):
    """Middleware providing standardized filesystem tools"""
    
    def __init__(self, root_dir: str = "/tmp/tradingagents"):
        self.root_dir = Path(root_dir)
        self.root_dir.mkdir(parents=True, exist_ok=True)
    
    @property
    def tools(self) -> List[BaseTool]:
        return [ls, read_file, write_file, edit_file, glob, grep]
    
    def modify_prompt(self, prompt: str, agent_type: str) -> str:
        fs_instructions = """
        
## Filesystem Tools

You have access to filesystem tools for managing files and data:
- `ls(directory)`: List files in a directory (requires absolute path)
- `read_file(file_path, offset=0, limit=None)`: Read file content with pagination
- `write_file(file_path, content, overwrite=True)`: Create or overwrite files
- `edit_file(file_path, old_string, new_string)`: Perform exact string replacements
- `glob(pattern, root_dir="/")`: Find files matching a pattern
- `grep(pattern, file_path, context_lines=0)`: Search for text in files

**Important:**
- All file paths must be absolute (start with `/`)
- Use these tools to save large analysis results (context offloading)
- Use for reading configuration files or historical reports
- Use for exporting data for external tools
"""
        return prompt + fs_instructions
```

**Context Offloading Example:**
```python
# Agent saves large report to file instead of keeping in state
def market_analyst_agent(state):
    # Generate large technical analysis report
    report = generate_technical_analysis(state["company_of_interest"])
    
    # Save to file (context offloading)
    report_path = f"/tmp/tradingagents/reports/{state['company_of_interest']}_market.txt"
    write_file(report_path, report)
    
    # Store reference in state instead of full report
    state["market_report_path"] = report_path
    state["market_report_summary"] = summarize(report, max_length=500)
    
    return state
```

---

## 6. Human-in-the-Loop Integration

### 6.1 Implementation with LangGraph Interrupts

```python
# tradingagents/middleware/hitl.py
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import StateGraph
from typing import Dict, Any, List

class HumanInTheLoopMiddleware(TradingMiddleware):
    """Middleware for human approval workflows"""
    
    def __init__(
        self,
        interrupt_on: Dict[str, Dict] = None,
        checkpointer = None
    ):
        """
        Args:
            interrupt_on: Dict mapping tool names to interrupt config
                Example: {
                    "execute_trade": {
                        "allowed_decisions": ["approve", "edit", "reject"],
                        "threshold": 10000  # Require approval for trades > $10k
                    }
                }
            checkpointer: LangGraph checkpointer (default: MemorySaver)
        """
        self.interrupt_on = interrupt_on or {}
        self.checkpointer = checkpointer or MemorySaver()
    
    @property
    def tools(self) -> List[BaseTool]:
        return []  # No tools, uses graph interrupts
    
    def should_interrupt(self, state: Dict[str, Any]) -> bool:
        """Check if execution should be interrupted"""
        # Check if any tool calls match interrupt conditions
        messages = state.get("messages", [])
        for msg in messages:
            if hasattr(msg, 'tool_calls') and msg.tool_calls:
                for tool_call in msg.tool_calls:
                    tool_name = tool_call.get('name', '')
                    if tool_name in self.interrupt_on:
                        return True
        return False
    
    def get_interrupt_config(self) -> Dict[str, Any]:
        """Get interrupt configuration for graph"""
        return {
            "interrupt_before": self._get_interrupt_nodes(),
            "checkpointer": self.checkpointer
        }
    
    def _get_interrupt_nodes(self) -> List[str]:
        """Get list of nodes that should interrupt"""
        # Map tool names to node names
        interrupt_nodes = []
        for tool_name in self.interrupt_on.keys():
            # Map tool to node (e.g., "execute_trade" -> "Portfolio Manager")
            node_name = self._tool_to_node(tool_name)
            if node_name:
                interrupt_nodes.append(node_name)
        return interrupt_nodes
    
    def _tool_to_node(self, tool_name: str) -> str:
        """Map tool name to graph node name"""
        mapping = {
            "execute_trade": "Risk Judge",
            "approve_trade": "Portfolio Manager",
            # Add more mappings
        }
        return mapping.get(tool_name)
```

**Usage:**
```python
# Create graph with HITL
from tradingagents.middleware.hitl import HumanInTheLoopMiddleware

hitl_middleware = HumanInTheLoopMiddleware(
    interrupt_on={
        "execute_trade": {
            "allowed_decisions": ["approve", "edit", "reject"],
            "threshold": 10000  # Require approval for trades > $10k
        }
    }
)

graph = TradingAgentsGraph(
    middleware=[hitl_middleware],
    config=config
)

# Run with interrupts
config = {"configurable": {"thread_id": "user_123"}}
result = graph.invoke(input_state, config=config)

# Graph pauses at interrupt point
# User reviews and approves/rejects
# Resume execution
graph.update_state(
    config["configurable"]["thread_id"],
    {"approved": True, "user_notes": "Looks good"}
)
```

---

## 7. Context Management & Token Optimization

### 7.1 Token Counting & Monitoring

```python
# tradingagents/middleware/token_tracker.py
from typing import Dict, Any
import tiktoken

class TokenTracker:
    """Track token usage across agent execution"""
    
    def __init__(self, model: str = "gpt-4o"):
        self.encoding = tiktoken.encoding_for_model(model)
        self.token_counts: Dict[str, int] = {}
    
    def count_tokens(self, text: str) -> int:
        """Count tokens in text"""
        return len(self.encoding.encode(text))
    
    def count_state_tokens(self, state: Dict[str, Any]) -> int:
        """Count total tokens in state"""
        total = 0
        for key, value in state.items():
            if isinstance(value, str):
                total += self.count_tokens(value)
            elif isinstance(value, dict):
                total += self.count_state_tokens(value)
            elif isinstance(value, list):
                for item in value:
                    if isinstance(item, str):
                        total += self.count_tokens(item)
        return total
    
    def track_agent_tokens(self, agent_name: str, state: Dict[str, Any]):
        """Track tokens for specific agent"""
        tokens = self.count_state_tokens(state)
        self.token_counts[agent_name] = tokens
        return tokens

# Integration
class TokenTrackingMiddleware(TradingMiddleware):
    """Middleware for token usage tracking"""
    
    def __init__(self):
        self.tracker = TokenTracker()
    
    def post_process(self, state: Dict[str, Any]) -> Dict[str, Any]:
        # Track tokens
        agent_name = state.get("current_agent", "unknown")
        tokens = self.tracker.track_agent_tokens(agent_name, state)
        
        # Add to state for monitoring
        state["_token_count"] = tokens
        state["_total_tokens"] = sum(self.tracker.token_counts.values())
        
        return state
```

### 7.2 Smart Context Pruning

```python
# tradingagents/middleware/context_pruner.py
class ContextPruner:
    """Intelligently prune context to reduce tokens"""
    
    def prune_messages(self, messages: List, max_tokens: int = 10000) -> List:
        """Prune message history while preserving important context"""
        total_tokens = sum(self.count_tokens(str(msg)) for msg in messages)
        
        if total_tokens <= max_tokens:
            return messages
        
        # Keep system messages
        # Keep recent messages (last 10)
        # Summarize older messages
        pruned = []
        system_msgs = [m for m in messages if m.type == "system"]
        recent_msgs = messages[-10:]
        old_msgs = messages[:-10]
        
        pruned.extend(system_msgs)
        
        if old_msgs:
            summary = self.summarize_messages(old_msgs)
            pruned.append(summary)
        
        pruned.extend(recent_msgs)
        
        return pruned
```

---

## 8. Implementation Roadmap

### Phase 1: Foundation (Week 1-2)

**Goals:**
- Implement base middleware infrastructure
- Add token tracking
- Add basic summarization

**Tasks:**
1. Create `tradingagents/middleware/` package
2. Implement `TradingMiddleware` base class
3. Implement `TokenTrackingMiddleware`
4. Implement `SummarizationMiddleware` (basic)
5. Integrate into `TradingAgentsGraph`

**Success Criteria:**
- Middleware system functional
- Token tracking working
- Summarization reduces tokens by 30%+

### Phase 2: Planning & Filesystem (Week 3-4)

**Goals:**
- Add todo list functionality
- Standardize filesystem tools
- Context offloading

**Tasks:**
1. Implement `TodoListMiddleware`
2. Implement `FilesystemMiddleware`
3. Add context offloading to agents
4. Update agent prompts

**Success Criteria:**
- Agents can create and track todos
- Filesystem tools available to all agents
- Large reports saved to files

### Phase 3: Advanced Features (Week 5-6)

**Goals:**
- Sub-agent delegation
- Human-in-the-loop
- Advanced summarization

**Tasks:**
1. Implement `SubAgentMiddleware`
2. Implement `HumanInTheLoopMiddleware`
3. Enhance summarization (team-level)
4. Performance optimization

**Success Criteria:**
- Dynamic sub-agent spawning works
- HITL interrupts functional
- Token reduction > 50%

### Phase 4: Optimization & Testing (Week 7-8)

**Goals:**
- Performance tuning
- Comprehensive testing
- Documentation

**Tasks:**
1. Benchmark token usage
2. Optimize summarization prompts
3. Add integration tests
4. Update documentation

**Success Criteria:**
- Token costs reduced by 50%+
- All tests passing
- Documentation complete

---

## Cost-Benefit Analysis

### Current Costs (Estimated)

**Per Analysis:**
- Analyst Team: ~15,000 tokens
- Research Team: ~25,000 tokens  
- Trader: ~10,000 tokens
- Risk Team: ~30,000 tokens
- Portfolio Manager: ~5,000 tokens
- **Total: ~85,000 tokens**

**At $0.01 per 1k tokens:**
- Cost per analysis: $0.85
- 100 analyses/day: $85/day = $2,550/month

### With Summarization

**Per Analysis (After Summarization):**
- Analyst Team: ~15,000 tokens â†’ summarized to 2,000
- Research Team: ~8,000 tokens (uses summarized input)
- Trader: ~5,000 tokens (uses summarized input)
- Risk Team: ~12,000 tokens (uses summarized input)
- Portfolio Manager: ~3,000 tokens
- **Total: ~30,000 tokens**

**Savings:**
- Cost per analysis: $0.30 (65% reduction)
- 100 analyses/day: $30/day = $900/month
- **Monthly savings: $1,650**

### With Sub-Agent Delegation

**Additional Savings:**
- Only run needed agents: ~20% reduction
- Isolated context: ~10% reduction
- **Total reduction: ~75%**

**Final Cost:**
- Cost per analysis: $0.21
- 100 analyses/day: $21/day = $630/month
- **Monthly savings: $1,920**

---

## Conclusion

This deep dive provides:
1. âœ… **Detailed technical designs** for each pattern
2. âœ… **Code examples** showing integration
3. âœ… **Cost-benefit analysis** demonstrating value
4. âœ… **Implementation roadmap** with clear phases

**Key Takeaways:**
- Middleware pattern enables clean extensibility
- Summarization can reduce costs by 65%+
- Todo lists improve UX and transparency
- Sub-agent delegation adds flexibility
- Filesystem tools enable better organization

**Next Steps:**
1. Review and prioritize patterns
2. Start with Phase 1 (Foundation)
3. Measure baseline token usage
4. Implement incrementally
5. Monitor cost savings

